{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":2606735493402488236,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":100,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"1d3NThw5FIbhe+k1Cx+fH9vcymgUkYRELSGIgIw0Qtz7FBm6mrSjrsXhXbBBNLgfWY2/Klf5uHjafb3+/PP7p/3tt7uH3eVfT7ubuy9Xj/u72+XV0/PF7vP9/uZm//3T2x/vyssXMfn1hocfV7cvrx8er+4fd5e1y8Xu+vbr7lJLXYBv+5vr3WUrzxdTU2vx2tR6Pzatz39fLHpFdUV1Q3VH9UD1ltRdxmtTr2XSO6oPUveC6oLqFdUV1Q3VHdUD1dGsOppVR7MaaFYDzWqgWQ00q4FmNdCsBprVQLPasmMmqr82Da2Tnv3cR62vTYfLpAeqN1TvqD5IvZe0fmg6mk26oHp2vI+1qZQyfzTK8sbyzvLB8o3lO8sPlB+F5YXl2dQONrWDTe1gUzvY1I5saqXUtvoxHfBHh/2B+rUU2BfYr7CvsG+w73k/jv6Y/ID9Bvsd9vP5FVv9dnqBVaXAvsB+hX2FfYN9h/2A/Qb7HfbT+RVZj88ip8satRbYF9ivsK+wb7DvsB+w32C/wz6cX4Xzq3B+Fc6vwvlVOL8K51fh/CqcX4Xzq3B+02UFslyiHPzlaHzqpxfnl2Xm1Xeb+p9ent/yK+wr7BvsO+wH7DfY77A/WD/g/Aac34DzG3B+A85vwPkNOL8B5zfg/Aac33QBgoT0gx+qk58dP8sM53D/YfnWJz9gv8F+h/3B+ulihC1fYL/CvsK+wT6c3w7nt8P57XB+O5zfAed3wPkdcH4HnN8B5ze9Pl5trV+sNhUwanp9ebmC1oPvNvsG9z99fDOvqx+zH7DfYL/D/mD99Prvli+wX9/VH5OveV9Wv/9WgvyHxkMP5cr1bWXry33BqbGXtRdexnjb+FfP7cP23D9sz+PD9rx92J73j9rz9Nr6sjrQ1rlBOb13oem16Y25R3ptessP2G+sn17b3fj7an78aFl99cmvsK+wb7DvsB+w32C/w/54V3+a+1mBfYH9Cvv5/Nrx+OnT8dMM9h32A/Yb7HfYH6zvhT2/u8A+fO/IFfbh+afD80+H558Ozz+9w/5g/YDzG3B+A85vwPkNOL8B5zdfexDrnYHl23bqt3TtSl/3sUvX2W+w32E/XZvRo6x+TNe/6bX1LV9gv8K+wr7BvsN+wH4+v33dGzjKdP3bO+wP1h8F9gX2K+wr7Bvs+7v60/2HEbDfYL/Dfj6/bT2/DzmdX1l+7/+GL7BfYV9h32DfYf89z79/8ht6frf83v8Nn50/mxTYF9ivsK+wb7DvsB+wD+dX4PwKnN8K57fC+a1wfvN7z6OvezdaOd27YQp/Pvm91SN8PT/2uf8K+wb7DvsB+w32O+wP1k+vv2/5Avtwfg3Or8H5NTi/BufX4Pzm9/6fP3/l9/5v+Onx33Tdm9l89hX2DfYd9gP2G+x32E+fv9rx2X1NT5+daPm9/xu+wH6FfYV9g32H/YD9Bvsd9uH8Nji/Dc5vg/Pb4Pw2OL/5+orq67Mfa7TJ77A/WD9fX7HhC+xX2FfYN9hPn7/qOPrT3mrL11ds+A320/nV47PjdHp2nOXrK877+fqKDT89/tXW+jqd6rctv76/3KI9+DbtX7D8+v6Gnx4/yyF+9Ued/IH6nl/f3/DTx3873j+3FpNfYV9h32DfYT9gv8F+h/3B+vn1/Q0fzq/A+RU4vwLnV+D8Cpzf/Pr42fmD59fHN3yB/fT417HWX1mZPv/8s/E3fIN9h/30+Nd+HP+lTX6D/Q77g/Xzz8bf8AX2K+zre/oyjf98/YY2P/pz//P5jbN+wH6D/fz889z1qefrN877+fqNDV9gv8K+wn52/J/758mern6IONx8izbrHdUHqafrNs7rguoV1RXVs+erWB8FHiGT7qgeqN5QvaP6IPV0jcZ5XVC9orqiOprVQLMaaFYDzWqgWQ0uq8/Lq3+u7vdXn2+uH5Z3vPzy5+2Xx/3d7evLx39//P+bpfF/","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"70":{"source":"use crate::keccak256::keccak256;\n\n#[export]\nfn test_keccak256_0() -> [u8; 32] {\n    keccak256([], 0)\n}\n\n#[export]\nfn test_keccak256_1(input: [u8; 1], len: u32) -> [u8; 32] {\n    keccak256(input, len)\n}\n\n#[export]\nfn test_keccak256_100(input: [u8; 100], len: u32) -> [u8; 32] {\n    keccak256(input, len)\n}\n\n#[export]\nfn test_keccak256_135(input: [u8; 135], len: u32) -> [u8; 32] {\n    keccak256(input, len)\n}\n\n#[test]\nfn smoke_test() {\n    let input = [0xbd];\n    let result = [\n        0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19, 0x37,\n        0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca, 0x4b, 0x3b,\n        0x1a, 0xbf,\n    ];\n    assert_eq(keccak256(input, input.len()), result);\n}\n\n#[test]\nfn hash_hello_world() {\n    let input = \"Hello world!\".as_bytes();\n    let result = [\n        0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n        0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n        0xea, 0xab,\n    ];\n    assert_eq(keccak256(input, input.len()), result);\n}\n\n#[test]\nfn var_size_hash() {\n    let input = [\n        189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,\n        207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\n    ];\n    let result = [\n        226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170, 219,\n        171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n    ];\n    assert_eq(keccak256(input, 13), result);\n}\n","path":"/home/jtriley/docs/zk/nr/keccak256/src/tests.nr"},"72":{"source":"use std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\nuse std::hash::keccak;\n\n/// Word size in bytes\nglobal WORD_SIZE: u32 = 8;\n\n/// Block size in bytes\nglobal BLOCK_SIZE_IN_BYTES: u32 = (1600 - 256 * 2) / WORD_SIZE;\n\n/// Lanes per block\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\n\n/// Keccak-f lanes\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], msg_len: u32) -> [u8; 32] {\n    assert(N >= msg_len);\n\n    let mut block_bytes = [0; (N / BLOCK_SIZE_IN_BYTES + 1) * BLOCK_SIZE_IN_BYTES];\n\n    if is_unconstrained() {\n        for i in 0..msg_len {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < msg_len {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n\n    let real_max_blocks = (msg_len + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[msg_len] = 0x01;\n    block_bytes[(real_max_blocks * BLOCK_SIZE_IN_BYTES) - 1] = 0x80;\n\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n        let mut sliced = 0;\n        let mut v = 1;\n\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if i == 0 {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] ^= sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n\n            state = keccakf1600(state);\n        }\n    } else {\n        for i in 0..LIMBS_PER_BLOCK {\n            state[i] = sliced_buffer[i];\n        }\n\n        state = keccakf1600(state);\n\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] ^= sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n        }\n    }\n\n    let mut result = [0; 32];\n\n    for i in 0..4 {\n        let lane: [u8; 8] = (state[i] as Field).to_le_bytes();\n\n        for j in 0..8 {\n            result[i * 8 + j] = lane[j];\n        }\n    }\n\n    result\n}\n","path":"/home/jtriley/docs/zk/nr/keccak256/src/keccak256.nr"}},"names":["test_keccak256_100"],"brillig_names":["test_keccak256_100"]}