{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":11153673390658102740,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":1,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"1d3BThw5EMbxd5kzh7arXOXKq6xWEUlINBKCKJCVVhHvvk2W8STtaPpQ/A9c0AyYn6zBX7e7XW5+HD7dfPj+5f3x7vP9w+HdXz8Ot/cfrx+P93frux9PV4cP3463t8cv73/99mF5/qL1Z/uHr9d3z28fHq+/PR7eFe9Xh5u7T+uriPX3Px9vbw7vfHm6mpqq20tT7f3ctD79fXVQIXEl8UbiRuJO4j2JtxIvTVtdtniAeFtIvJB4JXEhcSXxRuJG4k7iZEIbmVAjE2pkQo1MqJEJNTKhRibUyIQamVAjE+rZoWi1vTQ1qVs8+weNWl+aRitb3EjcSbyTeIB4X9J4OeGuW7yQeHacRz/hZVmmz0VQXVG9obqhuqN6R/Ug9VhQvaA6mtVAsxpoVgPNaqBZjWxWy1J98LY9wEdn+UD59fOC/QL7FfYF9hX2W963sx+Tb7DvsN9hP5/fosP37WVUKQvsF9ivsC+wr7DfYN9g32G/w346v+tHcGq79nbr1wX2C+xX2BfYV9hvsG+w77DfYR/Or8D5FTi/AudX4PwKnF+B8ytwfgXOr8D5FTi/6SqE9Qw+/Fpt66eX80vT4Ted+p9e0d/zK+wL7CvsN9g32HfY77AfrG9wfg3Or8H5NTi/BufX4PwanF+D82twfg3Ob7rOYE3oaGsik58dP1XidP9hfdkm32DfYb/DfrB+uvJgzy+wX2FfYF9hH85vh/Pb4fx2OL8dzm/A+Q04vwHnN+D8Bpzf9Pp41VGlWHUqU6zp9eXaqpz8prOvcP/Txzdtdfg2+wb7Dvsd9oP10+u/e36B/fqqfky+5P0y/P5bpfEfGoecqpLrr1Wsz/cFp8ZtGWVLbfmlG2vjnz3XN9vz9mZ7bm+25/5me97fas/Ta+u1jbWD9eX23kVNr03vzD3Sa9N7vsG+s356bXfn7yv58SPL8KVNfoV9gX2F/Qb7BvsO+x3241X9ae6nC+wX2K+wn8+vno+fbTp+qsJ+g32DfYf9DvvB+m1hz++twD5876gJ7MPzzwbPPxs8/2zw/LN12A/WNzi/BufX4PwanF+D82twfvO1BzbuDKwvfet7unaljz3r60Lo7Dvsd9hP12Z0W4Zv0/Vvem19zy+wX2FfYF9hv8G+wX4+v33sDYxluv7tHfaD9WOB/QL7FfYF9hX226v60/2HMNh32O+wn8+vj/N7lO38SvJ7/3f8AvsV9gX2FfYb7L/m+fdPvqPnd8nv/d/x2fmzlAX2C+xX2BfYV9hvsG+wD+e3wPktcH4rnN8K57fC+c3vPbc+2vqy3bshAn8++b3VYW207XP/BfYV9hvsG+w77HfYD9ZPr7/v+QX24fwqnF+F86twfhXOr8L5ze/9v3z+yu/93/HT499l7M30NvsC+wr7DfYN9h32O+ynz19+fnafy/bZiZLf+7/jF9ivsC+wr7DfYN9g32G/wz6cX4fz63B+Hc6vw/l1OL/5+oraxrMfq/nkd9gP1s/XV+z4BfYr7AvsK+ynz181zv60t1ry9RU7vsN+Or9yfnacTM+Ok3x9xWU/X1+x46fH/3oLZvhT/bbk1/dVhq/T/gXJr+/v+Onxox7Djzr5gfqaX9/f8dPHfz3fP1e3ya+wL7CvsN9g32DfYb/DfrB+fn1/x4fzW+D8Fji/Bc5vgfNb4Pzm18cvzh80vz6+4xfYT49/iVF/tR6NJ19gX2G/wX56/K+X0GffJ99hv8N+sH7+2fg7foH9Cvvymn6Zxn++fkO8nf25//n82kXfYN9hPz//vHR9qvn6jct+vn5jxy+wX2FfYD87/i/9j2RNVz+YnW6+mc96R/Ug9XTdxmW9oHpFdUH17PnKxqPAzcqkN1Q3VHdU76gepJ6u0bisF1SvqC6ojmbV0KwamlVDs2poVo3L6tP67p/rb8frD7c3D+tvPP/w+93Hx+P93cvbx3+//v+TtfF/","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"70":{"source":"use crate::keccak256::keccak256;\n\n#[export]\nfn test_keccak256_0() -> [u8; 32] {\n    keccak256([], 0)\n}\n\n#[export]\nfn test_keccak256_1(input: [u8; 1], len: u32) -> [u8; 32] {\n    keccak256(input, len)\n}\n\n#[export]\nfn test_keccak256_100(input: [u8; 100], len: u32) -> [u8; 32] {\n    keccak256(input, len)\n}\n\n#[export]\nfn test_keccak256_135(input: [u8; 135], len: u32) -> [u8; 32] {\n    keccak256(input, len)\n}\n\n#[test]\nfn smoke_test() {\n    let input = [0xbd];\n    let result = [\n        0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19, 0x37,\n        0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca, 0x4b, 0x3b,\n        0x1a, 0xbf,\n    ];\n    assert_eq(keccak256(input, input.len()), result);\n}\n\n#[test]\nfn hash_hello_world() {\n    let input = \"Hello world!\".as_bytes();\n    let result = [\n        0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n        0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n        0xea, 0xab,\n    ];\n    assert_eq(keccak256(input, input.len()), result);\n}\n\n#[test]\nfn var_size_hash() {\n    let input = [\n        189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,\n        207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\n    ];\n    let result = [\n        226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170, 219,\n        171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n    ];\n    assert_eq(keccak256(input, 13), result);\n}\n","path":"/home/jtriley/docs/zk/nr/keccak256/src/tests.nr"},"72":{"source":"use std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\nuse std::hash::keccak;\n\n/// Word size in bytes\nglobal WORD_SIZE: u32 = 8;\n\n/// Block size in bytes\nglobal BLOCK_SIZE_IN_BYTES: u32 = (1600 - 256 * 2) / WORD_SIZE;\n\n/// Lanes per block\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\n\n/// Keccak-f lanes\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], msg_len: u32) -> [u8; 32] {\n    assert(N >= msg_len);\n\n    let mut block_bytes = [0; (N / BLOCK_SIZE_IN_BYTES + 1) * BLOCK_SIZE_IN_BYTES];\n\n    if is_unconstrained() {\n        for i in 0..msg_len {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < msg_len {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n\n    let real_max_blocks = (msg_len + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[msg_len] = 0x01;\n    block_bytes[(real_max_blocks * BLOCK_SIZE_IN_BYTES) - 1] = 0x80;\n\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n        let mut sliced = 0;\n        let mut v = 1;\n\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if i == 0 {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] ^= sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n\n            state = keccakf1600(state);\n        }\n    } else {\n        for i in 0..LIMBS_PER_BLOCK {\n            state[i] = sliced_buffer[i];\n        }\n\n        state = keccakf1600(state);\n\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] ^= sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n        }\n    }\n\n    let mut result = [0; 32];\n\n    for i in 0..4 {\n        let lane: [u8; 8] = (state[i] as Field).to_le_bytes();\n\n        for j in 0..8 {\n            result[i * 8 + j] = lane[j];\n        }\n    }\n\n    result\n}\n","path":"/home/jtriley/docs/zk/nr/keccak256/src/keccak256.nr"}},"names":["test_keccak256_1"],"brillig_names":["test_keccak256_1"]}