{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":8613967352337297852,"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"70":{"source":"use crate::keccak256::keccak256;\n\n#[export]\nfn test_keccak256_0() -> [u8; 32] {\n    keccak256([], 0)\n}\n\n#[export]\nfn test_keccak256_1(input: [u8; 1], len: u32) -> [u8; 32] {\n    keccak256(input, len)\n}\n\n#[export]\nfn test_keccak256_100(input: [u8; 100], len: u32) -> [u8; 32] {\n    keccak256(input, len)\n}\n\n#[export]\nfn test_keccak256_135(input: [u8; 135], len: u32) -> [u8; 32] {\n    keccak256(input, len)\n}\n\n#[test]\nfn smoke_test() {\n    let input = [0xbd];\n    let result = [\n        0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19, 0x37,\n        0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca, 0x4b, 0x3b,\n        0x1a, 0xbf,\n    ];\n    assert_eq(keccak256(input, input.len()), result);\n}\n\n#[test]\nfn hash_hello_world() {\n    let input = \"Hello world!\".as_bytes();\n    let result = [\n        0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n        0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n        0xea, 0xab,\n    ];\n    assert_eq(keccak256(input, input.len()), result);\n}\n\n#[test]\nfn var_size_hash() {\n    let input = [\n        189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,\n        207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\n    ];\n    let result = [\n        226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170, 219,\n        171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n    ];\n    assert_eq(keccak256(input, 13), result);\n}\n","path":"/home/jtriley/docs/zk/nr/keccak256/src/tests.nr"},"72":{"source":"use std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\nuse std::hash::keccak;\n\n/// Word size in bytes\nglobal WORD_SIZE: u32 = 8;\n\n/// Block size in bytes\nglobal BLOCK_SIZE_IN_BYTES: u32 = (1600 - 256 * 2) / WORD_SIZE;\n\n/// Lanes per block\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\n\n/// Keccak-f lanes\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], msg_len: u32) -> [u8; 32] {\n    assert(N >= msg_len);\n\n    let mut block_bytes = [0; (N / BLOCK_SIZE_IN_BYTES + 1) * BLOCK_SIZE_IN_BYTES];\n\n    if is_unconstrained() {\n        for i in 0..msg_len {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < msg_len {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n\n    let real_max_blocks = (msg_len + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[msg_len] = 0x01;\n    block_bytes[(real_max_blocks * BLOCK_SIZE_IN_BYTES) - 1] = 0x80;\n\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n        let mut sliced = 0;\n        let mut v = 1;\n\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if i == 0 {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] ^= sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n\n            state = keccakf1600(state);\n        }\n    } else {\n        for i in 0..LIMBS_PER_BLOCK {\n            state[i] = sliced_buffer[i];\n        }\n\n        state = keccakf1600(state);\n\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] ^= sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n        }\n    }\n\n    let mut result = [0; 32];\n\n    for i in 0..4 {\n        let lane: [u8; 8] = (state[i] as Field).to_le_bytes();\n\n        for j in 0..8 {\n            result[i * 8 + j] = lane[j];\n        }\n    }\n\n    result\n}\n","path":"/home/jtriley/docs/zk/nr/keccak256/src/keccak256.nr"}},"names":["test_keccak256_0"],"brillig_names":["test_keccak256_0"]}